.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.35
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::DB::Das::BioSQL 3"
.TH Bio::DB::Das::BioSQL 3 "2009-04-23" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Bio::DB::Das::BioSQL \- DAS\-style access to a BioSQL database
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 12
\& # Open up a feature database
\& $db = Bio::DB::Das::BioSQL\->new(
\&                                 driver   => \(aqmysql\(aq,
\&                                 dbname => \(aqbiosql\(aq,
\&                                 biodbname => \(aqtest\(aq,
\&                                 host   => \(aqswiss\(aq,
\&                                 user   => \(aqlstein\(aq,
\&                                 pass   => undef,
\&                                 port   => undef,
\&                                 namespace   => \(aqnamespace\(aq,
\&                                 version   => version_number,
\&                                ) or die;
.Ve
.PP
.Vb 3
\&  @segments = $db\->segment(\-name  => \(aqNT_29921.4\(aq,
\&                           \-start => 1,
\&                           \-end   => 1000000);
.Ve
.PP
.Vb 1
\&  # segments are Bio::Das::SegmentI \- compliant objects
.Ve
.PP
.Vb 2
\&  # fetch a list of features
\&  @features = $db\->features(\-segment=>$segment, \-type=>[\(aqtype1\(aq,\(aqtype2\(aq,\(aqtype3\(aq]);
.Ve
.PP
.Vb 4
\&  $stream   = $db\->get_seq_stream(\-type=>[\(aqtype1\(aq,\(aqtype2\(aq,\(aqtype3\(aq]);
\&  while (my $feature = $stream\->next_seq) {
\&     # each feature is a Bio::SeqFeatureI\-compliant object
\&  }
.Ve
.PP
.Vb 2
\&  # get all feature types
\&  @types   = $db\->types;
.Ve
.PP
.Vb 2
\&  # count types
\&  %types   = $db\->types(\-enumerate=>1);
.Ve
.PP
.Vb 4
\&  @feature = $db\->get_feature_by_name($class=>$name);
\&  @feature = $db\->get_feature_by_target($target_name);
\&  @feature = $db\->get_feature_by_attribute($att1=>$value1,$att2=>$value2);
\&  $feature = $db\->get_feature_by_id($id);
.Ve
.PP
.Vb 1
\&  $error = $db\->error;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Bio::DB::Das::BioSQL is a simplified alternative interface to sequence
annotation databases used by the distributed annotation system (see
Bio::Das). In this scheme, the genome is represented as a series of
features, a subset of which are named.  Named features can be used as
reference points for retrieving \*(L"segments\*(R" (see
Bio::DB::Das::Segment), and these can, in turn, be used as the
basis for exploring the genome further.
.PP
In addition to a name, each feature has a \*(L"class\*(R", which is
essentially a namespace qualifier and a \*(L"type\*(R", which describes what
type of feature it is.  Das uses the \s-1GO\s0 consortium's ontology of
feature types, and so the type is actually an object of class
Bio::Das::FeatureTypeI (see
Bio::Das::FeatureTypeI). Bio::DB::Das::BioSQL provides methods for
interrogating the database for the types it contains and the counts of
each type.
.SH "FEEDBACK"
.IX Header "FEEDBACK"
.Sh "Mailing Lists"
.IX Subsection "Mailing Lists"
User feedback is an integral part of the evolution of this and other
Bioperl modules. Send your comments and suggestions preferably to one
of the Bioperl mailing lists.  Your participation is much appreciated.
.PP
.Vb 1
\&  bioperl\-l@bio.perl.org
.Ve
.Sh "Reporting Bugs"
.IX Subsection "Reporting Bugs"
Report bugs to the Bioperl bug tracking system to help us keep track
the bugs and their resolution.  Bug reports can be submitted via email
or the web:
.PP
.Vb 2
\&  bioperl\-bugs@bio.perl.org
\&  http://bio.perl.org/bioperl\-bugs/
.Ve
.SH "AUTHORS \- Lincoln Stein, Vsevolod (Simon) Ilyushchenko"
.IX Header "AUTHORS - Lincoln Stein, Vsevolod (Simon) Ilyushchenko"
Email lstein@cshl.edu, simonf@cshl.edu
.SH "APPENDIX"
.IX Header "APPENDIX"
The rest of the documentation details each of the object
methods. Internal methods are usually preceded with a _
.Sh "new"
.IX Subsection "new"
.Vb 10
\& Title   : new
\& Usage   : $db    = Bio::DB::Das::BioSQL(
\&                                    driver    => \(aqmysql\(aq,
\&                                    dbname    => \(aqbiosql\(aq,
\&                                    biodbname => \(aqswissprot\(aq,
\&                                    host      => \(aqlocalhost\(aq,
\&                                    user      => \(aqjimbo\(aq,
\&                                    pass      => \(aqsupersecret\(aq,
\&                                    port      => 3306,
\&                                       );
.Ve
.PP
.Vb 4
\& Function: Open up a Bio::DB::DasI interface to a BioSQL database
\& Returns : a new Bio::DB::Das::BioSQL object
\& Args    : See L<Bio::DB::Das::BioSQL::BioDatabaseAdaptor\->new_from_registry()
\&           The new() method takes the same arguments exactly.
.Ve
.Sh "segment"
.IX Subsection "segment"
.Vb 5
\& Title   : segment
\& Usage   : $db\->segment(@args);
\& Function: create a segment object
\& Returns : segment object(s)
\& Args    : see below
.Ve
.PP
This method generates a Bio::Das::SegmentI object (see
Bio::Das::SegmentI).  The segment can be used to find overlapping
features and the raw sequence.
.PP
When making the \fIsegment()\fR call, you specify the \s-1ID\s0 of a sequence
landmark (e.g. an accession number, a clone or contig), and a
positional range relative to the landmark.  If no range is specified,
then the entire region spanned by the landmark is used to generate the
segment.
.PP
Arguments are \-option=>value pairs as follows:
.PP
.Vb 1
\& \-name         ID of the landmark sequence.
.Ve
.PP
.Vb 3
\& \-class        A namespace qualifier.  It is not necessary for the
\&               database to honor namespace qualifiers, but if it
\&               does, this is where the qualifier is indicated.
.Ve
.PP
.Vb 3
\& \-version      Version number of the landmark.  It is not necessary for
\&               the database to honor versions, but if it does, this is
\&               where the version is indicated.
.Ve
.PP
.Vb 3
\& \-start        Start of the segment relative to landmark.  Positions
\&               follow standard 1\-based sequence rules.  If not specified,
\&               defaults to the beginning of the landmark.
.Ve
.PP
.Vb 2
\& \-end          End of the segment relative to the landmark.  If not specified,
\&               defaults to the end of the landmark.
.Ve
.PP
The return value is a list of Bio::Das::SegmentI objects.  If the method
is called in a scalar context and there are no more than one segments
that satisfy the request, then it is allowed to return the segment.
Otherwise, the method must throw a \*(L"multiple segment exception\*(R".
.Sh "features"
.IX Subsection "features"
.Vb 6
\& Title   : features
\& Usage   : $db\->features(@args)
\& Function: get all features, possibly filtered by type
\& Returns : a list of Bio::SeqFeatureI objects
\& Args    : see below
\& Status  : public
.Ve
.PP
This routine will retrieve features in the database regardless of
position.  It can be used to return all features, or a subset based on
their type
.PP
Arguments are \-option=>value pairs as follows:
.PP
.Vb 3
\&  \-types     List of feature types to return.  Argument is an array
\&             of Bio::Das::FeatureTypeI objects or a set of strings
\&             that can be converted into FeatureTypeI objects.
.Ve
.PP
.Vb 2
\&  \-callback   A callback to invoke on each feature.  The subroutine
\&              will be passed each Bio::SeqFeatureI object in turn.
.Ve
.PP
.Vb 1
\&  \-attributes A hash reference containing attributes to match.
.Ve
.PP
The \-attributes argument is a hashref containing one or more attributes
to match against:
.PP
.Vb 2
\&  \-attributes => { Gene => \(aqabc\-1\(aq,
\&                   Note => \(aqconfirmed\(aq }
.Ve
.PP
Attribute matching is simple exact string matching, and multiple
attributes are ANDed together.
.PP
If one provides a callback, it will be invoked on each feature in
turn.  If the callback returns a false value, iteration will be
interrupted.  When a callback is provided, the method returns undef.
.Sh "types"
.IX Subsection "types"
.Vb 5
\& Title   : types
\& Usage   : $db\->types(@args)
\& Function: return list of feature types in database
\& Returns : a list of Bio::Das::FeatureTypeI objects
\& Args    : see below
.Ve
.PP
This routine returns a list of feature types known to the database. It
is also possible to find out how many times each feature occurs.
.PP
Arguments are \-option=>value pairs as follows:
.PP
.Vb 1
\&  \-enumerate  if true, count the features
.Ve
.PP
The returned value will be a list of Bio::Das::FeatureTypeI objects
(see Bio::Das::FeatureTypeI.
.PP
If \-enumerate is true, then the function returns a hash (not a hash
reference) in which the keys are the stringified versions of
Bio::Das::FeatureTypeI and the values are the number of times each
feature appears in the database.
.PP
\&\s-1NOTE:\s0 This currently raises a \*(L"not\-implemented\*(R" exception, as the
BioSQL \s-1API\s0 does not appear to provide this functionality.
.Sh "search_notes"
.IX Subsection "search_notes"
.Vb 6
\& Title   : search_notes
\& Usage   : $db\->search_notes($search_term,$max_results)
\& Function: full\-text search on features, ENSEMBL\-style
\& Returns : an array of [$name,$description,$score]
\& Args    : see below
\& Status  : public
.Ve
.PP
This routine performs a full-text search on feature attributes (which
attributes depend on implementation) and returns a list of
[$name,$description,$score], where \f(CW$name\fR is the feature \s-1ID\s0,
\&\f(CW$description\fR is a human-readable description such as a locus line, and
\&\f(CW$score\fR is the match strength.
.PP
\&\s-1THIS\s0 \s-1METHOD\s0 \s-1CURRENTLY\s0 \s-1RETURNS\s0 \s-1EMPTY\s0 \s-1BECAUSE\s0 I \s-1CAN\s0'T \s-1GET\s0 \s-1\fIFETCH_BY_QUERY\s0()\fR
\&\s-1TO\s0 \s-1WORK\s0.
.Sh "biosql"
.IX Subsection "biosql"
.Vb 5
\& Title   : biosql
\& Usage   : $biosql  = $db\->biosql([$biosql])
\& Function: Get/set the underlying Bio::DB::Das::BioSQL::BioDatabaseAdaptor
\& Returns : An Bio::DB::Das::BioSQL::BioDatabaseAdaptor
\& Args    : A new Bio::DB::Das::BioSQL::BioDatabaseAdaptor (optional)
.Ve
.Sh "_segclass"
.IX Subsection "_segclass"
.Vb 6
\& Title   : _segclass
\& Usage   : $class = $db\->_segclass
\& Function: returns the perl class that we use for segment() calls
\& Returns : a string containing the segment class
\& Args    : none
\& Status  : reserved for subclass use
.Ve
.Sh "_adaptorclass"
.IX Subsection "_adaptorclass"
.Vb 6
\& Title   : _adaptorclass
\& Usage   : $class = $db\->_adaptorclass
\& Function: returns the perl class that we use as a BioSQL database adaptor
\& Returns : a string containing the segment class
\& Args    : none
\& Status  : reserved for subclass use
.Ve
